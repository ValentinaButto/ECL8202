<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Données spatiales</title>

<script src="libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="libs/bootstrap-3.3.5/css/spacelab.min.css" rel="stylesheet" />
<script src="libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="libs/navigation-1.1/tabsets.js"></script>
<link href="libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Données spatiales</h1>

</div>


<div id="introduction-aux-statistiques-spatiales" class="section level1">
<h1>Introduction aux statistiques spatiales</h1>
<div id="types-danalyses-spatiales" class="section level2">
<h2>Types d’analyses spatiales</h2>
<p>Ce cours présente une introduction à trois types d’analyses spatiales: l’analyse des patrons de points, les modèles géostatistiques et les modèles de données aréales.</p>
<p>Dans l’<strong>analyse des patrons de points</strong>, nous avons des données ponctuelles représentant la position d’individus ou d’événements dans une région d’étude et nous supposons que tous les individus ou événements ont été recensés dans cette région. Cette analyse s’intéresse à la distribution des positions des points eux-mêmes. Voici quelques questions typiques de l’analyse des patrons de points:</p>
<ul>
<li><p>Les points sont-ils disposés aléatoirement ou agglomérés?</p></li>
<li><p>Deux types de points sont-ils disposés indépendamment?</p></li>
</ul>
<p>Les <strong>modèles géostatistiques</strong> visent à représenter la distribution spatiale de variables continues qui sont mesurés à certains points d’échantillonnage. Ils supposent que les mesures de ces variables à différents points sont corrélées en fonction de la distance entre ces points. Parmi les applications des modèles géostatistiques, notons le lissage des données spatiales (ex.: produire une carte d’une variable sur l’ensemble d’une région en fonction des mesures ponctuelles) et la prédiction de ces variables pour des points non-échantillonnés.</p>
<p>Les <strong>données aréales</strong> sont des mesures prises non pas à des points, mais pour des régions de l’espace représentées par des polygones (ex.: divisions du territoire, cellules d’une grille). Les modèles représentant ces types de données définissent un réseau de voisinage reliant les régions et incluent une corrélation spatiale entre régions voisines.</p>
</div>
<div id="stationnarité-et-isotropie" class="section level2">
<h2>Stationnarité et isotropie</h2>
<p>Plusieurs analyses spatiales supposent que les variables sont <strong>stationnaires</strong> dans l’espace. Comme pour la stationnarité dans le domaine temporel, cette propriété signifie que les statistiques sommaires (moyenne, variance et corrélations entre mesures d’une variable) ne varient pas avec une translation dans l’espace. Par exemple, la corrélation spatiale entre deux points peut dépendre de la distance les séparant, mais pas de leur position absolue.</p>
<p>En particulier, il ne peut pas y avoir de tendance à grande échelle (souvent appelée <em>gradient</em> dans un contexte spatial), ou bien cette tendance doit être prise en compte afin de modéliser la corrélation spatiale des résidus.</p>
<p>Dans le cas de l’analyse des patrons de points, la stationnarité (aussi appelée homogénéité dans ce contexte) signifie que la densité des points ne suit pas de tendance à grande échelle.</p>
<p>Dans un modèle statistique <strong>isotropique</strong>, les corrélations spatiales entre les mesures à deux points dépendent seulement de la distance entre ces points, pas de la direction. Dans ce cas, les statistiques sommaires ne varient pas si on effectue une rotation dans l’espace.</p>
</div>
<div id="données-géoréférencées" class="section level2">
<h2>Données géoréférencées</h2>
<p>Les études environnementales utilisent de plus en plus de données provenant de sources de données géospatiales, c’est-à-dire des variables mesurées sur une grande partie du globe (ex.: climat, télédétection). Le traitement de ces données requiert des concepts liés aux systèmes d’information géographique (SIG), qui ne sont pas couverts dans ce cours, alors que nous nous concentrons sur les aspects statistiques de données variant dans l’espace.</p>
<p>L’utilisation de données géospatiales ne signifie pas nécessairement qu’il faut avoir recours à des statistiques spatiales. Par exemple, il est courant d’extraire les valeurs de ces variables géographiques à des points d’étude pour expliquer une réponse biologique observée sur le terrain. Dans ce cas, l’utilisation de statistiques spatiales est seulement nécessaire en présence d’une corrélation spatiale dans les résidus, après avoir tenu compte de l’effet des prédicteurs.</p>
</div>
</div>
<div id="analyse-des-patrons-de-points" class="section level1">
<h1>Analyse des patrons de points</h1>
<div id="patron-de-points-et-processus-ponctuel" class="section level2">
<h2>Patron de points et processus ponctuel</h2>
<p>Un patron de points (<em>point pattern</em>) décrit la position spatiale (le plus souvent en 2D) d’individus ou d’événements, représentés par des points, dans une aire d’étude donnée, souvent appelée la <em>fenêtre</em> d’observation.</p>
<p>On suppose que chaque point a une étendue spatiale négligeable par rapport aux distances entre les points. Des méthodes plus complexes existent pour traiter des patrons spatiaux d’objets qui ont une largeur non-néligeable, mais ce sujet dépasse la portée de ce cours.</p>
<p>Un processus ponctuel (<em>point process</em>) est un modèle statistique qui peut être utilisé pour simuler des patrons de points ou expliquer un patron de points observé.</p>
</div>
<div id="structure-spatiale-totalement-aléatoire" class="section level2">
<h2>Structure spatiale totalement aléatoire</h2>
<p>Une structure spatiale totalement aléatoire (<em>complete spatial randomness</em>) est un des patrons les plus simples, qui sert de modèle nul pour évaluer les caractéristiques de patrons de points réels. Dans ce patron, la présence d’un point à une position donnée est indépendante de la présence de points dans un voisinage.</p>
<p>Le processus créant ce patron est un processus de Poisson homogène. Selon ce modèle, le nombre de points dans toute région de superficie <span class="math inline">\(A\)</span> suit une distribution de Poisson: <span class="math inline">\(N(A) \sim \text{Pois}(\lambda A)\)</span>, où <span class="math inline">\(\lambda\)</span> est l’<em>intensité</em> du processus (i.e. la densité de points). <span class="math inline">\(N\)</span> est indépendant entre deux régions disjointes, peu importe comment ces régions sont définies.</p>
<p>Dans le graphique ci-dessous, seul le patron à droite est totalement aléatoire. Le patron à gauche montre une agrégation des points (probabilité plus grande d’observer un point si on est à proximité d’un autre point), tandis que le patron du centre montre une répulsion (faible probabilité d’observer un point très près d’un autre).</p>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
</div>
<div id="indice-k-de-ripley" class="section level2">
<h2>Indice <span class="math inline">\(K\)</span> de Ripley</h2>
<p>L’indice <span class="math inline">\(K\)</span> de Ripley est une des statistiques sommaires qui permet de comparer un patron de points à une structure spatiale totalement aléatoire.</p>
<p>Cet indice est calculé pour différentes distances <span class="math inline">\(r\)</span>. Pour une distance <span class="math inline">\(r\)</span> donnée, <span class="math inline">\(K(r)\)</span> mesure le nombre moyen de points dans un rayon <span class="math inline">\(r\)</span> tracé autour d’un point du patron, normalisé par l’intensité <span class="math inline">\(\lambda\)</span>.</p>
<p>Pour un patron totalement aléatoire, la moyenne de <span class="math inline">\(N(r)\)</span> est <span class="math inline">\(\lambda \pi r^2\)</span>, donc en théorie <span class="math inline">\(K(r) = \pi r^2\)</span>. Une valeur de <span class="math inline">\(K(r)\)</span> supérieure pour un patron donné signifie qu’il y a agrégation des points dans ce rayon, tandis qu’une valeur inférieure signifie qu’il y a une répulsion.</p>
<p>Pour tester si un patron est compatible avec l’hypothèse nulle d’une structure spatiale totalement aléatoire, nous pouvons générer des patrons aléatoires de même intensité que celui observé, puis calculer <span class="math inline">\(K(r)\)</span> pour chaque simulation afin de créer une <em>enveloppe</em> de valeurs (ex.: contenant 95% des simulations) au-delà de laquelle l’hypothèse nulle sera rejetée.</p>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<p>Les graphiques ci-dessus montrent la valeur de <span class="math inline">\(K(r)\)</span> pour des patrons montrés ci-dessus pour des valeurs de <span class="math inline">\(r\)</span> allant jusqu’à 1/4 de la largeur de la fenêtre. La courbe pointillée rouge indique la valeur théorique pour un patron aléatoire et la zone grise constitue l’enveloppe produite par 99 simulations. Le patron agrégé montre un excès de voisins jusqu’à <span class="math inline">\(r = 0.25\)</span> et le patron avec répulsion montre un déficit significatif de voisins pour les petites valeurs de <span class="math inline">\(r\)</span>.</p>
</div>
<div id="effet-de-lhétérogénéité" class="section level2">
<h2>Effet de l’hétérogénéité</h2>
<p>Le graphique ci-dessous illustre un patron de points <em>hétérogène</em>, c’est-à-dire qu’il présente un gradient d’intensité (plus de points à gauche qu’à droite).</p>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<p>Un gradient de densité peut être confondu avec une agrégation des points, comme on peut voir sur le graphique du <span class="math inline">\(K\)</span> de Ripley correspondant. Afin de différencier les deux phénomènes, nous pouvons corriger la fonction <span class="math inline">\(K\)</span> pour que le nombre de voisins soit normalisé non pas par l’intensité globale, mais l’intensité estimée à la position du point.</p>
<p>Pour ce type d’analyse, il faut aussi s’assurer que le modèle nul corresponde à un processus de Poisson hétérogène (c’est-à-dire que les points demeurent indépendants l’un de l’autre, mais leur densité varie dans l’espace).</p>
<p>Voici ci-dessous le graphique du <span class="math inline">\(K\)</span> pour ce même patron, après avoir tenu compte de l’hétérogénéité.</p>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<p>On peut seulement différencier un gradient de densité d’un processus d’agrégation des points si les deux processus opèrent à différentes échelles. En général, nous pouvons retirer l’effet d’un gradient à grande échelle pour détecter une agrégation à plus petite échelle.</p>
</div>
<div id="relation-entre-deux-patrons-de-points" class="section level2">
<h2>Relation entre deux patrons de points</h2>
<p>Finalement, considérons un cas où nous avons deux patrons de points, par exemple la position des arbres de deux espèces dans une parcelle (points oranges et verts dans le graphique ci-dessous). Chacun des deux patrons peut présenter ou non des agrégations de points.</p>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<p>Sans égard à cette agrégation au niveau de l’espèce, nous voulons déterminer si les deux espèces sont disposées indépendamment. Autrement dit, la probabilité d’observer un arbre d’une espèce dépend-elle de la présence d’un arbre de l’autre espèce à une distance donnée?</p>
<p>La version bivariée du <span class="math inline">\(K\)</span> de Ripley permet de répondre à cette question. Pour deux patrons désignés 1 et 2, l’indice <span class="math inline">\(K_{12}(r)\)</span> calcule le nombre moyen de points du patron 2 à une distance <span class="math inline">\(r\)</span> d’un point du patron 1, normalisé par la densité du patron 2.</p>
<p>En théorie, cet indice est symétrique, donc <span class="math inline">\(K_{12}(r) = K_{21}(r)\)</span> et il n’y a pas de différence selon qu’on choisisse les points du patron 1 ou 2 comme points “focaux” pour l’analyse. Cependant, en raison du caractère aléatoire des patrons, la distribution de <span class="math inline">\(K\)</span> déterminée par simulation d’un modèle nul peut varier dans les deux cas.</p>
<p>Le choix d’un modèle nul approprié est important ici. Afin de déterminer s’il existe une attraction ou une répulsion significative entre les deux patrons, il faut randomiser la position d’un patron relative à celle de l’autre patron, tout en conservant la structure spatiale de chaque patron pris isolément.</p>
<p>Une des façons d’effectuer cette randomisation consiste à décaler l’un des deux patrons horizontalement et/ou verticalement d’une distance aléatoire. La partie du patron qui “sort” d’un côté de la fenêtre est rattachée de l’autre côté. Cette méthode s’appelle une translation toroïdale (<em>toroidal shift</em>), car en connectant le haut et le bas ainsi que la gauche et la droite d’une surface rectangulaire, on obtient la forme d’un tore (un “beigne” en trois dimensions).</p>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
<p>Le graphique ci-dessus illustre une translation du patron vert vers la droite, tandis que le patron orange reste au même endroit. Les points verts dans la zone ombragée sont ramenés de l’autre côté. Notez que si cette méthode préserve de façon générale la structure de chaque patron tout en randomisant leur position relative, elle peut comporter certains inconvénients, comme de diviser des amas de points qui se trouvent près du point de coupure.</p>
</div>
<div id="pour-en-savoir-plus" class="section level2">
<h2>Pour en savoir plus</h2>
<p>Cette partie visait à illustrer les principaux concepts de l’analyse des patrons de points. Vous êtes invités à consulter des ressources spécialisées, comme le manuel recommandé de Wiegand et Moloney (2013) dans les références, afin d’en apprendre plus sur ces méthodes. Entre autres:</p>
<ul>
<li><p>Outre le <span class="math inline">\(K\)</span> de Ripley, plusieurs autres statistiques sommaires peuvent être utilisées pour décrire des patrons de points, par exemple, la distance moyenne du plus proche voisin.</p></li>
<li><p>L’estimation des statistiques sommaires d’un patron de point doit tenir compte des <em>effets de bordure</em>, c’est-à-dire que nous ne connaissons pas tous les voisins des points à proximité de la bordure de la fenêtre d’observation. Nous n’avons pas discuté ici de ces méthodes de correction.</p></li>
<li><p>En plus d’analyser la position des points, nous pouvons analyser l’agrégation de caractéristiques des points, ou <em>marques</em>. Par exemple, si un patron spatial d’arbres contient des arbres morts et vivants, nous pouvons vérifier si la mortalité est spatialement aléatoire ou agrégée dans l’espace.</p></li>
</ul>
</div>
</div>
<div id="patrons-de-points-dans-r" class="section level1">
<h1>Patrons de points dans R</h1>
<p>Pour cet exemple, nous utilisons le jeu de données <a href="../donnees/semis_xy.csv">semis_xy.csv</a>, qui représente les coordonnées <span class="math inline">\((x, y)\)</span> de semis de deux espèces (<em>sp</em>, B = bouleau et P = peuplier) dans une placette de 15 x 15 m.</p>
<pre class="r"><code>semis &lt;- read.csv(&quot;../donnees/semis_xy.csv&quot;)
head(semis)</code></pre>
<pre><code>##       x    y sp
## 1 14.73 0.05  P
## 2 14.72 1.71  P
## 3 14.31 2.06  P
## 4 14.16 2.64  P
## 5 14.12 4.15  B
## 6  9.88 4.08  B</code></pre>
<p>Le package <em>spatstat</em> permet d’effectuer des analyses de patrons de point dans R. La première étape consiste à transformer notre tableau de données en objet <code>ppp</code> (patron de points) avec la fonction du même nom. Dans cette fonction, nous spécifions quelles colonnes contiennent les coordonnées <em>x</em> et <em>y</em> ainsi que les marques (<code>marks</code>), qui seront ici les codes d’espèce. Il faut aussi spécifier une fenêtre d’observation (<code>window</code>) à l’aide de la fonction <code>owin</code>, à laquelle nous indiquons les limites de la placette en <em>x</em> et <em>y</em>.</p>
<pre class="r"><code>library(spatstat)

semis &lt;- ppp(x = semis$x, y = semis$y, marks = as.factor(semis$sp),
             window = owin(xrange = c(0, 15), yrange = c(0, 15)))
semis</code></pre>
<pre><code>## Marked planar point pattern: 281 points
## Multitype, with levels = B, P 
## window: rectangle = [0, 15] x [0, 15] units</code></pre>
<p>Les marques peuvent être numériques ou catégorielles. Notez que pour des marques catégorielles comme c’est le cas ici, il faut convertir explicitement la variable en facteur.</p>
<p>La fonction <code>plot</code> appliquée à un patron de points montre un diagramme du patron.</p>
<pre class="r"><code>plot(semis)</code></pre>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<p>La fonction <code>intensity</code> calcule la densité des points de chaque espèce par unité de surface, ici en <span class="math inline">\(m^2\)</span>.</p>
<pre class="r"><code>intensity(semis)</code></pre>
<pre><code>##         B         P 
## 0.6666667 0.5822222</code></pre>
<p>Pour analyser d’abord séparément la distribution de chaque espèce, nous séparons le patron avec <code>split</code>. Puisque le patron contient des marques, la séparation se fait automatiquement en fonction de la valeur des marques. Le résultat est une liste de deux patrons de points.</p>
<pre class="r"><code>semis_split &lt;- split(semis)
plot(semis_split)</code></pre>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p>La fonction <code>Kest</code> calcule le <span class="math inline">\(K\)</span> de Ripley pour une série de distances allant (par défaut) jusqu’à 1/4 de la largeur de la fenêtre. Ici, nous l’appliquons au premier patron (bouleau) en choisissant <code>semis_split[[1]]</code>. Notez que les doubles crochets sont nécessaires pour choisir un élément d’une liste dans R.</p>
<p>L’argument <code>correction = "iso"</code> indique d’appliquer une correction isotropique pour les effets de bordure.</p>
<pre class="r"><code>k &lt;- Kest(semis_split[[1]], correction = &quot;iso&quot;)
plot(k)</code></pre>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
<p>Selon ce graphique, il semble y avoir une excès de voisins à partir d’un rayon de 1 m. Pour vérifier s’il s’agit d’un écart significatif, nous produisons une enveloppe de simulation avec la fonction <code>envelope</code>. Le permier argument d’<code>envelope</code> est un patron de point auquel les simulations seront comparées, le deuxième une fonction à calculer (ici, <code>Kest</code>) pour chaque patron simulé, puis on y ajoute les arguments de la fonction <code>Kest</code> (ici, seulement <code>correction</code>).</p>
<pre class="r"><code>plot(envelope(semis_split[[1]], Kest, correction = &quot;iso&quot;), legend = FALSE)</code></pre>
<pre><code>## Generating 99 simulations of CSR  ...
## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
## 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
## 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,  99.
## 
## Done.</code></pre>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
<p>Tel qu’indiqué par le message, cette fonction effectue par défaut 99 simulations de l’hypothèse nulle correspondant à une structure spatiale totalement aléatoire (CSR, pour <em>complete spatial randomness</em>).</p>
<p>La courbe observée sort de l’enveloppe des 99 simulations près de <span class="math inline">\(r = 2\)</span>. Il faut être prudent de ne pas interpréter trop rapidement un résultat sortant de l’enveloppe. Même s’il y a environ une probabilité de 1% d’obtenir un résultat plus extrême selon l’hypothèse nulle à une distance donnée, l’enveloppe est calculée pour un grand nombre de valeurs de la distance et nous n’effectuons pas de correction pour les comparaisons multiples. Ainsi, un écart significatif pour une très petite plage de valeurs de <span class="math inline">\(r\)</span> peut être simplement dû au hasard.</p>
<p>En contrepartie, le graphique semblable pour le peuplier montre une agrégation importante jusqu’à 3 m et au-delà.</p>
<pre class="r"><code>plot(envelope(semis_split[[2]], Kest, correction = &quot;iso&quot;), legend = FALSE)</code></pre>
<pre><code>## Generating 99 simulations of CSR  ...
## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
## 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
## 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,  99.
## 
## Done.</code></pre>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<p>Pour déterminer s’il y a une dépendance entre la position des deux espèces, nous calculons l’indice bivarié <span class="math inline">\(K_{ij}\)</span>, avec le bouleau comme espèce focale <span class="math inline">\(i\)</span> et le peuplier comme espèce voisine <span class="math inline">\(j\)</span>, par le biais de la fonction <code>Kcross</code>.</p>
<pre class="r"><code>plot(Kcross(semis, i = &quot;B&quot;, j = &quot;P&quot;, correction = &quot;iso&quot;), legend = FALSE)</code></pre>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
<p>Ici, le <span class="math inline">\(K\)</span> observé est inférieur à la valeur théorique, indiquant une répulsion possible des deux patrons.</p>
<p>Pour déterminer l’enveloppe du <span class="math inline">\(K\)</span> selon l’hypothèse nulle d’indépendance des deux patrons, nous devons spécifier que les simulations doivent être basées sur une translation des patrons et non sur une structure spatiale totalement aléatoire. Nous indiquons que les simulations doivent utiliser la fonction <code>rshift</code> (translation aléatoire) avec l’argument <code>simulate = rshift</code>. Comme pour le cas précédent, il faut répéter dans la fonction <code>envelope</code> tous les arguments nécessaires pour <code>Kcross</code>.</p>
<pre class="r"><code>plot(envelope(semis, Kcross, simulate = rshift, i = &quot;P&quot;, j = &quot;B&quot;,
              correction = &quot;iso&quot;), legend = FALSE)</code></pre>
<pre><code>## Generating 99 simulations by evaluating function  ...
## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
## 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
## 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,  99.
## 
## Done.</code></pre>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
<p>Ici, la courbe observée se situe totalement dans l’enveloppe, donc nous ne rejetons pas l’hypothèse nulle d’indépendance des deux patrons.</p>
</div>
<div id="modèles-géostatistiques" class="section level1">
<h1>Modèles géostatistiques</h1>
<p>La géostatistique désigne un groupe de techniques tirant leur origine en sciences de la Terre. Elle s’intéresse à des variables distribuées de façon continue dans l’espace, dont on cherche à estimer la distribution en échantillonnant un nombre de points. Un exemple classique de ces techniques provient du domaine minier, où l’on cherchait à créer une carte de la concentration du minerai sur un site à partir d’échantillons pris à différents points du site.</p>
<p>Pour ces modèles, nous supposerons que <span class="math inline">\(z(x, y)\)</span> est une variable spatiale stationnaire mesurée selon les coordonnées <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span>.</p>
<div id="variogramme" class="section level2">
<h2>Variogramme</h2>
<p>Un aspect central de la géostatistique est l’estimation du variogramme <span class="math inline">\(\gamma_z\)</span> de la variable <span class="math inline">\(z\)</span>. Le variogramme est égal à la moitié de l’écart carré moyen entre les valeurs de <span class="math inline">\(z\)</span> pour deux points <span class="math inline">\((x_i, y_i)\)</span> et <span class="math inline">\((x_j, y_j)\)</span> séparés par une distance <span class="math inline">\(h\)</span>.</p>
<p><span class="math display">\[\gamma_z(h) = \frac{1}{2} \text{E} \left[ \left( z(x_i, y_i) - z(x_j, y_j) \right)^2 \right]_{d_{ij} = h}\]</span></p>
<p>Dans cette équation, la fonction <span class="math inline">\(\text{E}\)</span> avec l’indice <span class="math inline">\(d_{ij}=h\)</span> désigne l’espérance statistique (autrement dit, la moyenne) de l’écart au carré entre les valeurs de <span class="math inline">\(z\)</span> pour les points séparés par une distance <span class="math inline">\(h\)</span>.</p>
<p>Si on préfère exprimer l’autocorrélation <span class="math inline">\(\rho_z(h)\)</span> entre mesures de <span class="math inline">\(z\)</span> séparées par une distance <span class="math inline">\(h\)</span>, celle-ci est reliée au variogramme par l’équation:</p>
<p><span class="math display">\[\gamma_z = \sigma_z^2(1 - \rho_z)\]</span> ,</p>
<p>où <span class="math inline">\(\sigma_z^2\)</span> est la variance globale de <span class="math inline">\(z\)</span>.</p>
<p>Notez que <span class="math inline">\(\gamma_z = \sigma_z^2\)</span> si nous sommes à une distance où les mesures de <span class="math inline">\(z\)</span> sont indépendantes, donc <span class="math inline">\(\rho_z = 0\)</span>. Dans ce cas, on voit bien que <span class="math inline">\(\gamma_z\)</span> s’apparente à une variance, même s’il est parfois appelé “semivariogramme” ou “semivariance” en raison du facteur 1/2 dans l’équation ci-dessus.</p>
</div>
<div id="modèles-théoriques-du-variogramme" class="section level2">
<h2>Modèles théoriques du variogramme</h2>
<p>Plusieurs modèles paramétriques ont été proposés pour représenter la corrélation spatiale en fonction de la distance entre points d’échantillonnage. Considérons d’abord une corrélation qui diminue de façon exponentielle:</p>
<p><span class="math display">\[\rho_z(h) = e^{-h/r}\]</span></p>
<p>Ici, <span class="math inline">\(\rho_z = 1\)</span> pour <span class="math inline">\(h = 0\)</span> et la corréaltion est multipliée par <span class="math inline">\(1/e \approx 0.37\)</span> pour chaque augmentation de <span class="math inline">\(r\)</span> de la distance. Dans ce contexte, <span class="math inline">\(r\)</span> se nomme la portée (<em>range</em>) de la corrélation.</p>
<p>À partir de l’équation ci-dessus, nous pouvons calculer le variogramme correspondant.</p>
<p><span class="math display">\[\gamma_z(h) = \sigma_z^2 (1 - e^{-h/r})\]</span></p>
<p>Voici une représentation graphique de ce variogramme.</p>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<p>En raison de la fonction exponentielle, la valeur de <span class="math inline">\(\gamma\)</span> à des grandes distances s’approche de la variance globale <span class="math inline">\(\sigma_z^2\)</span> sans exactement l’atteindre. Cette asymptote est appelée palier (<em>sill</em>) dans le contexte géostatistique et représentée par le symbole <span class="math inline">\(s\)</span>.</p>
<p>Finalement, il n’est parfois pas réaliste de supposer une corrélation parfaite lorsque la distance est nulle, en raison d’une variation possible de <span class="math inline">\(z\)</span> à très petite échelle. On peut ajouter au modèle un effet de pépite (<em>nugget</em>), noté <span class="math inline">\(n\)</span>, pour que <span class="math inline">\(\gamma = n\)</span> si <span class="math inline">\(h = 0\)</span>. Le terme pépite provient de l’origine minière de ces techniques, où une pépite d’un minerai pourrait être la source d’une variation abrupte de la concentration à petite échelle.</p>
<p>En ajoutant l’effet de pépite, le reste du variogramme est “compressé” pour conserver le même palier, ce qui résulte en l’équation suivante.</p>
<p><span class="math display">\[\gamma_z(h) = n + (s - n) (1 - e^{-h/r})\]</span></p>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<p>En plus du modèle exponentiel, deux autres modèles théoriques courants pour le variogramme sont le modèle gaussien (où la corrélation suit une courbe demi-normale), ainsi que le modèle sphérique (où le variogramme augmente de façon linéaire au départ pour ensuite courber et atteindre le palier à une distance égale à sa portée <span class="math inline">\(r\)</span>). Le modèle sphérique permet donc à la corrélation d’être exactement 0 à grande distance, plutôt que de s’approcher graduellement de zéro dans le cas des autres modèles.</p>
<table>
<colgroup>
<col width="22%" />
<col width="35%" />
<col width="41%" />
</colgroup>
<thead>
<tr class="header">
<th>Modèle</th>
<th><span class="math inline">\(\rho(h)\)</span></th>
<th><span class="math inline">\(\gamma(h)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Exponentiel</td>
<td><span class="math inline">\(\exp\left(-\frac{h}{r}\right)\)</span></td>
<td><span class="math inline">\(s \left(1 - \exp\left(-\frac{h}{r}\right)\right)\)</span></td>
</tr>
<tr class="even">
<td>Gaussien</td>
<td><span class="math inline">\(\exp\left(-\frac{h^2}{r^2}\right)\)</span></td>
<td><span class="math inline">\(s \left(1 - \exp\left(-\frac{h^2}{r^2}\right)\right)\)</span></td>
</tr>
<tr class="odd">
<td>Sphérique <span class="math inline">\((h &lt; r)\)</span> *</td>
<td><span class="math inline">\(1 - \frac{3}{2}\frac{h}{r} + \frac{1}{2}\frac{h^3}{r^3}\)</span></td>
<td><span class="math inline">\(s \left(\frac{3}{2}\frac{h}{r} - \frac{1}{2}\frac{h^3}{r^3} \right)\)</span></td>
</tr>
</tbody>
</table>
<p>* Pour le modèle sphérique, <span class="math inline">\(\rho = 0\)</span> et <span class="math inline">\(\gamma = s\)</span> si <span class="math inline">\(h \ge r\)</span>.</p>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
</div>
<div id="variogramme-empirique" class="section level2">
<h2>Variogramme empirique</h2>
<p>Pour estimer <span class="math inline">\(\gamma_z(h)\)</span> à partir de données empiriques, nous devons définir des classes de distance, donc grouper différentes distances dans une marge <span class="math inline">\(\pm \delta\)</span> autour d’une distance <span class="math inline">\(h\)</span>, puis calculer l’écart-carré moyen pour les paires de points dans cette classe de distance.</p>
<p><span class="math display">\[\hat{\gamma_z}(h) = \frac{1}{2 N_{\text{paires}}} \sum \left[ \left( z(x_i, y_i) - z(x_j, y_j) \right)^2 \right]_{d_{ij} = h \pm \delta}\]</span></p>
<p>Nous verrons dans la partie suivante comment estimer un variogramme dans R.</p>
</div>
<div id="variogramme-et-données-temporelles" class="section level2">
<h2>Variogramme et données temporelles</h2>
<p>Un variogramme peut aussi être estimé en fonction des écarts dans le temps, qui est dans ce cas considéré comme un espace à 1 dimension. Ceci permet de modéliser la dépendance temporelle pour une série de mesures prises à intervalles irréguliers, lorsque les modèles autorégressifs vus au dernier cours ne s’appliquent pas.</p>
</div>
<div id="modèle-de-régression-avec-corrélation-spatiale" class="section level2">
<h2>Modèle de régression avec corrélation spatiale</h2>
<p>L’équation suivante représente une régression linéaire multiple incluant une corrélation spatiale résiduelle:</p>
<p><span class="math display">\[v = \beta_0 + \sum_i \beta_i u_i + z + \epsilon\]</span></p>
<p>Ici, <span class="math inline">\(v\)</span> désigne la variable réponse et <span class="math inline">\(u\)</span> les prédicteurs, pour ne pas confondre avec les coordonnées spatiales <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span>.</p>
<p>En plus du résidu <span class="math inline">\(\epsilon\)</span> qui est indépendant entre les observations, le modèle inclut un terme <span class="math inline">\(z\)</span> qui représente la portion spatialement corrélée de la variance résiduelle.</p>
<p>Voici une suggestions d’étapes à suivre pour appliquer ce type de modèle:</p>
<ol style="list-style-type: decimal">
<li><p>Ajuster le modèle de régression sans corrélation spatiale.</p></li>
<li><p>Vérifier la présence de corrélation spatiale à partir du variogramme empirique des résidus.</p></li>
<li><p>Ajuster un ou plusieurs modèles de régression avec corrélation spatiale. On peut comparer avec l’AIC au besoin pour choisir la forme de la corrélation.</p></li>
</ol>
<p>Nous verrons dans la dernière partie du cours comment inclure des termes de corrélation spatiale dans des modèles complexes, comme les modèles mixtes ou bayésiens.</p>
</div>
</div>
<div id="modèles-géostatistiques-dans-r" class="section level1">
<h1>Modèles géostatistiques dans R</h1>
<p>Le package <em>gstat</em> contient des fonctions liées à la géostatistique. Pour cet exemple, nous utiliserons le jeu de données <code>oxford</code> de ce package, qui contient des mesures de propriétés physiques et chimiques pour 126 échantillons du sol d’un site, ainsi que leurs coordonnées <code>XCOORD</code> et <code>YCOORD</code>.</p>
<pre class="r"><code>library(gstat)

data(oxford)
str(oxford)</code></pre>
<pre><code>## &#39;data.frame&#39;:    126 obs. of  22 variables:
##  $ PROFILE  : num  1 2 3 4 5 6 7 8 9 10 ...
##  $ XCOORD   : num  100 100 100 100 100 100 100 100 100 100 ...
##  $ YCOORD   : num  2100 2000 1900 1800 1700 1600 1500 1400 1300 1200 ...
##  $ ELEV     : num  598 597 610 615 610 595 580 590 598 588 ...
##  $ PROFCLASS: Factor w/ 3 levels &quot;Cr&quot;,&quot;Ct&quot;,&quot;Ia&quot;: 2 2 2 3 3 2 3 2 3 3 ...
##  $ MAPCLASS : Factor w/ 3 levels &quot;Cr&quot;,&quot;Ct&quot;,&quot;Ia&quot;: 2 3 3 3 3 2 2 3 3 3 ...
##  $ VAL1     : num  3 3 4 4 3 3 4 4 4 3 ...
##  $ CHR1     : num  3 3 3 3 3 2 2 3 3 3 ...
##  $ LIME1    : num  4 4 4 4 4 0 2 1 0 4 ...
##  $ VAL2     : num  4 4 5 8 8 4 8 4 8 8 ...
##  $ CHR2     : num  4 4 4 2 2 4 2 4 2 2 ...
##  $ LIME2    : num  4 4 4 5 5 4 5 4 5 5 ...
##  $ DEPTHCM  : num  61 91 46 20 20 91 30 61 38 25 ...
##  $ DEP2LIME : num  20 20 20 20 20 20 20 20 40 20 ...
##  $ PCLAY1   : num  15 25 20 20 18 25 25 35 35 12 ...
##  $ PCLAY2   : num  10 10 20 10 10 20 10 20 10 10 ...
##  $ MG1      : num  63 58 55 60 88 168 99 59 233 87 ...
##  $ OM1      : num  5.7 5.6 5.8 6.2 8.4 6.4 7.1 3.8 5 9.2 ...
##  $ CEC1     : num  20 22 17 23 27 27 21 14 27 20 ...
##  $ PH1      : num  7.7 7.7 7.5 7.6 7.6 7 7.5 7.6 6.6 7.5 ...
##  $ PHOS1    : num  13 9.2 10.5 8.8 13 9.3 10 9 15 12.6 ...
##  $ POT1     : num  196 157 115 172 238 164 312 184 123 282 ...</code></pre>
<p>Supposons que nous souhaitons modéliser la concentration de magnésium (<code>MG1</code>), représentée en fonction de la position spatiale dans le graphique suivant.</p>
<pre class="r"><code>library(ggplot2)
ggplot(oxford, aes(x = YCOORD, y = XCOORD, size = MG1)) +
    geom_point() +
    coord_fixed()</code></pre>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-25-1.png" width="672" /></p>
<p>Notez que les axes <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span> ont été inversés par souci d’espace. La fonction <code>coord_fixed()</code> de <em>ggplot2</em> assure que l’échelle soit la même sur les deux axes, ce qui est utile pour représenter des données spatiales.</p>
<p>Nous voyons tout de suite que ces mesures ont été prises sur une grille de 100 m de côté. Il semble que la concentration de magnésium soit spatialement corrélée, bien qu’il puisse s’agir d’une corrélation induite par une autre variable. Nous savons notamment que la disponibilité de l’ion magnésium est reliée (négativement) au pH du sol (<code>PH1</code>).</p>
<pre class="r"><code>ggplot(oxford, aes(x = PH1, y = MG1)) +
    geom_point()</code></pre>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-26-1.png" width="672" /></p>
<p>La fonction <code>variogram</code> de <em>gstat</em> sert à estimer un variogramme à partir de données empiriques. Voici le résultat obtenu pour la variable <code>MG1</code>.</p>
<pre class="r"><code>var_mg &lt;- variogram(MG1 ~ 1, locations = ~ XCOORD + YCOORD, data = oxford)
var_mg</code></pre>
<pre><code>##     np     dist    gamma dir.hor dir.ver   id
## 1  225 100.0000 1601.404       0       0 var1
## 2  200 141.4214 1950.805       0       0 var1
## 3  548 215.0773 2171.231       0       0 var1
## 4  623 303.6283 2422.245       0       0 var1
## 5  258 360.5551 2704.366       0       0 var1
## 6  144 400.0000 2948.774       0       0 var1
## 7  570 427.5569 2994.621       0       0 var1
## 8  291 500.0000 3402.058       0       0 var1
## 9  366 522.8801 3844.165       0       0 var1
## 10 200 577.1759 3603.060       0       0 var1
## 11 458 619.8400 3816.595       0       0 var1
## 12  90 670.8204 3345.739       0       0 var1</code></pre>
<p>La formule <code>MG1 ~ 1</code> indique qu’aucun prédicteur linéaire n’est inclus dans ce modèle, tandis que l’argument <code>locations</code> indique quelles variables du tableau correspondent aux coordonnées spatiales.</p>
<p>Dans le tableau obtenu, <code>gamma</code> est la valeur du variogramme pour la classe de distance centrée sur <code>dist</code>, tandis que <code>np</code> est le nombre de paires de points dans cette classe. Ici, puisque les points sont situés sur une grille, nous obtenons des classes de distance régulières (ex.: 100 m pour les points voisins sur la grille, 141 m pour les voisins en diagonale, etc.) Nous pouvons illustrer le variogramme avec <code>plot</code>.</p>
<pre class="r"><code>plot(var_mg, col = &quot;black&quot;)</code></pre>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-28-1.png" width="672" /></p>
<p>Si nous voulons estimer la corrélation spatiale résiduelle de <code>MG1</code> après avoir inclus l’effet de <code>PH1</code>, nous pouvons ajouter ce prédicteur à la formule.</p>
<pre class="r"><code>var_mg &lt;- variogram(MG1 ~ PH1, locations = ~ XCOORD + YCOORD, data = oxford)
plot(var_mg, col = &quot;black&quot;)</code></pre>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-29-1.png" width="672" /></p>
<p>En incluant l’effet du pH, la portée de la corrélation spatiale semble diminuer, alors que le plateau est atteint autour de 300 m. Il semble même que le variogramme diminue au-delà de 400 m. En général, nous supposons que la variance entre deux points ne diminue pas avec la distance, à moins d’avoir un patron spatial périodique.</p>
<p>La fonction <code>fit.variogram</code> accepte comme arguments un variogramme estimé à partir des données, ainsi qu’un modèle théorique décrit dans une fonction <code>vgm</code>, puis estime les paramètres de ce modèle en fonction des données. L’ajustement se fait par la méthode des moindres carrés.</p>
<p>Par exemple, <code>vgm("Exp")</code> indique d’ajuster un modèle exponentiel.</p>
<pre class="r"><code>vfit &lt;- fit.variogram(var_mg, vgm(&quot;Exp&quot;))
vfit</code></pre>
<pre><code>##   model    psill    range
## 1   Nug    0.000  0.00000
## 2   Exp 1951.496 95.11235</code></pre>
<p>Il n’y a aucun effet de pépite, car <code>psill = 0</code> pour la partie <code>Nug</code> (<em>nugget</em>) du modèle. La partie exponentielle a un palier à 1951 (correspondant à <span class="math inline">\(\sigma_z^2\)</span>) et une portée de 95 m.</p>
<p>Pour comparer différents modèles, on peut donner un vecteur de noms de modèles à <code>vgm</code>. Dans l’exemple suivant, nous incluons les modèles exponentiel, gaussien (“Gau”) et sphérique (“Sph”).</p>
<pre class="r"><code>vfit &lt;- fit.variogram(var_mg, vgm(c(&quot;Exp&quot;, &quot;Gau&quot;, &quot;Sph&quot;)))
vfit</code></pre>
<pre><code>##   model    psill    range
## 1   Nug    0.000  0.00000
## 2   Exp 1951.496 95.11235</code></pre>
<p>Le modèle exponentiel demeure le mieux ajusté.</p>
<p>Finalement, nous pouvons superposer le modèle théorique et le variogramme empirique sur un même graphique.</p>
<pre class="r"><code>plot(var_mg, vfit, col = &quot;black&quot;)</code></pre>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-32-1.png" width="672" /></p>
</div>
<div id="données-aréales" class="section level1">
<h1>Données aréales</h1>
<p>Les données aréales sont des variables mesurées pour des régions de l’espace; ces régions sont définies par des polygones. Ce type de données est plus courant en sciences sociales, en géographie humaine et en épidémiologie, où les données sont souvent disponibles à l’échelle de divisions administratives du territoire.</p>
<p>Ce type de données apparaît aussi fréquemment dans la gestion des ressources naturelles. Par exemple, la carte suivante montre les unités d’aménagement forestier du Ministère de la Forêts, de la Faune et des Parcs du Québec.</p>
<p><img src="../images/cartes_unites.png" /></p>
<p>Supposons qu’une certaine variable soit disponible au niveau de ces divisions du territoire. Comment pouvons-nous modéliser la corrélation spatiale entre les unités qui sont spatialement rapprochées?</p>
<p>Une option serait d’appliquer les méthodes géostatistiques vues précédemment, en calculant par exemple la distance entre les centres des polygones.</p>
<p>Une autre option, qui est davantage privilégiée pour les données aréales, consiste à définir un réseau où chaque région est connectée aux régions voisines par un lien. On suppose ensuite que les variables sont directement corrélées entre régions voisines seulement. (Comme nous avons vu dans le cas des séries temporelles, les corrélations directes entre voisins immédiats génèrent aussi des corrélations indirectes pour une chaîne de voisins.)</p>
<p>Dans ce type de modèle, la corrélation n’est pas nécessairement la même d’un lien à un autre. Dans ce cas, chaque lien du réseau peut être associé à un <em>poids</em> représentant son importance pour la corrélation spatiale. Nous représentons ces poids par une matrice <span class="math inline">\(W\)</span> où <span class="math inline">\(w_{ij}\)</span> est le poids du lien entre les régions <span class="math inline">\(i\)</span> et <span class="math inline">\(j\)</span>. Une région n’a pas de lien avec elle-même, donc <span class="math inline">\(w_{ii} = 0\)</span>.</p>
<p>Un choix simple pour <span class="math inline">\(W\)</span> consiste à assigner un poids égal à 1 si les régions sont voisines, sinon 0 (poids binaires).</p>
<p>Outre les divisions du territoire en polygones, un autre exemple de données aréales consiste en une grille où la variable est compilée pour chaque cellule de la grille. Dans ce cas, une cellule a généralement 4 ou 8 cellules voisines, selon que les diagonales soient incluses ou non.</p>
<div id="indice-de-moran" class="section level2">
<h2>Indice de Moran</h2>
<p>Avant de discuter des modèles d’autocorrélation spatiale, nous présentons l’indice <span class="math inline">\(I\)</span> de Moran, qui permet de tester si une corrélation significative est présente entre régions voisines.</p>
<p>L’indice de Moran est un coefficient d’autocorrélation spatiale des <span class="math inline">\(z\)</span>, pondéré par les poids <span class="math inline">\(w_{ij}\)</span>. Il prend donc des valeurs entre -1 et 1.</p>
<p><span class="math display">\[I = \frac{N}{\sum_i \sum_j w_{ij}} \frac{\sum_i \sum_j w_{ij} (z_i - \bar{z}) (z_j - \bar{z})}{\sum_i (z_i - \bar{z})^2}\]</span></p>
<p>Dans cette équation, nous reconnaissons l’expression d’une corrélation, soit le produit des écarts à la moyenne de deux variables <span class="math inline">\(z_i\)</span> et <span class="math inline">\(z_j\)</span>, divisé par le produit de leurs écarts-types (qui est le même, donc on obtient la variance). La contribution de chaque paire <span class="math inline">\((i, j)\)</span> est multipliée par son poids <span class="math inline">\(w_{ij}\)</span> et le terme à gauche (le nombre de régions <span class="math inline">\(N\)</span> divisé par la somme des poids) assure que le résultat soit borné entre -1 et 1.</p>
<p>Puisque la distribution de <span class="math inline">\(I\)</span> est connue en l’absence d’autocorrélation spatiale, cette statistique permet de tester l’hypothèse nulle selon laquelle il n’y a pas de corrélation spatiale entre régions voisines.</p>
<p>Bien que nous ne verrons pas d’exemple dans ce cours-ci, l’indice de Moran peut aussi être appliqué aux données ponctuelles. Dans ce cas, on divise les paires de points en classes de distance et on calcule <span class="math inline">\(I\)</span> pour chaque classe de distance; le poids <span class="math inline">\(w_{ij} = 1\)</span> si la distance entre <span class="math inline">\(i\)</span> et <span class="math inline">\(j\)</span> se trouve dans la classe de distance voulue, 0 autrement.</p>
</div>
<div id="modèles-dautorégression-spatiale" class="section level2">
<h2>Modèles d’autorégression spatiale</h2>
<p>Rappelons-nous la formule pour une régression linéaire avec dépendance spatiale:</p>
<p><span class="math display">\[v = \beta_0 + \sum_i \beta_i u_i + z + \epsilon\]</span> ,</p>
<p>où <span class="math inline">\(z\)</span> est la portion de la variance résiduelle qui est spatialement corrélée.</p>
<p>Il existe deux principaux types de modèles autorégressifs pour représenter la dépendance spatiale de <span class="math inline">\(z\)</span>: l’autorégression conditionnelle (CAR) et l’autorégression simultanée (SAR).</p>
<div id="autorégression-conditionnelle-car" class="section level3">
<h3>Autorégression conditionnelle (CAR)</h3>
<p>Dans le modèle d’autorégression conditionnelle, la valeur de <span class="math inline">\(z_i\)</span> pour la région <span class="math inline">\(i\)</span> suit une distribution normale: sa moyenne dépend de la valeur <span class="math inline">\(z_j\)</span> des régions voisines, multipliée par le poids <span class="math inline">\(w_{ij}\)</span> et un coefficient de corrélation <span class="math inline">\(\rho\)</span>; son écart-type <span class="math inline">\(\sigma_{z_i}\)</span> peut varier d’une région à l’autre.</p>
<p><span class="math display">\[z_i \sim \text{N}\left(\sum_j \rho w_{ij} z_j,\sigma_{z_i} \right)\]</span></p>
<p>Dans ce modèle, si <span class="math inline">\(w_{ij}\)</span> est une matrice binaire (0 pour les non-voisins, 1 pour les voisins), alors <span class="math inline">\(\rho\)</span> est le coefficient de corrélation partielle entre régions voisines. Cela est semblable au modèle AR(1) dans le contexte temporel, où le coefficient d’autorégression indiquait la corrélation partielle.</p>
</div>
<div id="autorégression-simultanée-sar" class="section level3">
<h3>Autorégression simultanée (SAR)</h3>
<p>Dans le modèle d’autorégression simultanée, la valeur de <span class="math inline">\(z_i\)</span> est donnée directement par la somme de contributions des valeurs voisines <span class="math inline">\(z_j\)</span>, multipliées par <span class="math inline">\(\rho w_{ij}\)</span>, avec un résidu indépendant <span class="math inline">\(\nu_i\)</span> d’écart-type <span class="math inline">\(\sigma_z\)</span>.</p>
<p><span class="math display">\[z_i = \sum_j \rho w_{ij} z_j + \nu_i\]</span></p>
<p>À première vue, cela ressemble à un modèle autorégressif temporel. Il existe cependant une différence conceptuelle importante. Pour les modèles temporels, l’influence causale est dirigée dans une seule direction: <span class="math inline">\(v(t-2)\)</span> affecte <span class="math inline">\(v(t-1)\)</span> qui affecte ensuite <span class="math inline">\(v(t)\)</span>. Pour un modèle spatial, chaque <span class="math inline">\(z_j\)</span> qui affecte <span class="math inline">\(z_i\)</span> dépend à son tour de <span class="math inline">\(z_i\)</span>. Ainsi, pour déterminer la distribution conjointe des <span class="math inline">\(z\)</span>, il faut résoudre simultanément (d’où le nom du modèle) un système d’équations.</p>
<p>Pour cette raison, même si ce modèle ressemble à la formule du modèle conditionnel (CAR), les solutions des deux modèles diffèrent et dans le cas du SAR, le coefficient <span class="math inline">\(\rho\)</span> n’est pas directement égal à la corrélation partielle due à chaque région voisine.</p>
<p>Pour plus de détails sur les aspects mathématiques de ces modèles, vous pouvez consulter l’article de Ver Hoef et al. (2018) suggéré dans les références.</p>
<p>Pour l’instant, nous considérerons les SAR et les CAR comme deux types de modèles possibles pour représenter une corrélation spatiale sur un réseau. Nous pouvons toujours ajuster plusieurs modèles et les comparer avec l’AIC pour choisir la meilleure forme de la corrélation ou la meilleure matrice de poids.</p>
<p>Les modèles CAR et SAR partagent un avantage sur les modèles géostatistiques au niveau de l’efficacité. Dans un modèle géostatistique, les corrélations spatiales sont définies entre chaque paire de points, même si elles deviennent négligeables lorsque la distance augmente. Pour un modèle CAR ou SAR, seules les régions voisines contribuent et la plupart des poids sont égaux à 0, ce qui rend ces modèles plus rapides à ajuster qu’un modèle géostatistique lorsque les données sont massives.</p>
<p>Notez finalement qu’il existe aussi un équivalent spatial des modèles de moyenne mobile (MA) vus dans un contexte temporel. Cependant, puisque leur application est plus rare, nous n’en discutons pas dans ce cours.</p>
</div>
</div>
</div>
<div id="données-aréales-dans-r" class="section level1">
<h1>Données aréales dans R</h1>
<p>Pour illustrer l’analyse de données aréales dans R, nous chargeons les packages <em>spData</em> (contenant des exemples de données spatiales), <em>spdep</em> (pour définir des réseaux spatiaux et calculer l’indice de Moran) et <em>spatialreg</em> (pour les modèles SAR et CAR).</p>
<pre class="r"><code>library(spData)
library(spdep)
library(spatialreg)</code></pre>
<p>Nous utiliserons comme exemple le jeu de données spatial <code>us_states</code> qui contient des polygones pour 49 états américains (tous les états excluant l’Alaska et Hawaii, plus le District de Columbia).</p>
<pre class="r"><code>data(us_states)
head(us_states)</code></pre>
<pre><code>## Simple feature collection with 6 features and 6 fields
## geometry type:  MULTIPOLYGON
## dimension:      XY
## bbox:           xmin: -114.8136 ymin: 24.55868 xmax: -71.78699 ymax: 42.04964
## CRS:            EPSG:4269
##   GEOID        NAME   REGION             AREA total_pop_10 total_pop_15
## 1    01     Alabama    South 133709.27 [km^2]      4712651      4830620
## 2    04     Arizona     West 295281.25 [km^2]      6246816      6641928
## 3    08    Colorado     West 269573.06 [km^2]      4887061      5278906
## 4    09 Connecticut Norteast  12976.59 [km^2]      3545837      3593222
## 5    12     Florida    South 151052.01 [km^2]     18511620     19645772
## 6    13     Georgia    South 152725.21 [km^2]      9468815     10006693
##                         geometry
## 1 MULTIPOLYGON (((-88.20006 3...
## 2 MULTIPOLYGON (((-114.7196 3...
## 3 MULTIPOLYGON (((-109.0501 4...
## 4 MULTIPOLYGON (((-73.48731 4...
## 5 MULTIPOLYGON (((-81.81169 2...
## 6 MULTIPOLYGON (((-85.60516 3...</code></pre>
<p>Il s’agit d’un tableau de données spatial dont la dernière colonne définit le polygone correspondant à l’état et les autres colonnes définissent des variables qui y sont associées. Nous ne discuterons pas en détail de cette structure de données, mais notez que le packge <em>sf</em> permet d’importer des fichiers SIG vectoriels (<em>shapefiles</em>) dans ce format de données pour R.</p>
<p>Pour illustrer une des variables sur une carte, nous appelons la fonction <code>plot</code> avec le nom de la colonne entre crochets et guillemets.</p>
<pre class="r"><code>plot(us_states[&quot;REGION&quot;])</code></pre>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-35-1.png" width="672" /></p>
<p>Nous voulons ici modéliser le revenu médian dans chaque état en 2015. Cette variable <code>median_income_15</code> se trouve dans un autre jeu de données, <code>us_states_df</code>.</p>
<pre class="r"><code>data(us_states_df)
head(us_states_df)</code></pre>
<pre><code>## # A tibble: 6 x 5
##   state      median_income_10 median_income_15 poverty_level_10 poverty_level_15
##   &lt;chr&gt;                 &lt;dbl&gt;            &lt;dbl&gt;            &lt;dbl&gt;            &lt;dbl&gt;
## 1 Alabama               21746            22890           786544           887260
## 2 Alaska                29509            31455            64245            72957
## 3 Arizona               26412            26156           933113          1180690
## 4 Arkansas              20881            22205           502684           553644
## 5 California            27207            27035          4919945          6135142
## 6 Colorado              29365            30752           584184           653969</code></pre>
<p>Nous utilisons la fonction <code>inner_join</code> de <em>dplyr</em> pour joindre les deux jeux de données, en spécifiant avec <code>by</code> que la colonne <em>NAME</em> de <code>us_states</code> correspond à la colonne <em>state</em> de <code>us_states_df</code>.</p>
<pre class="r"><code>library(dplyr)
us_states &lt;- inner_join(us_states, us_states_df,
                        by = c(&quot;NAME&quot; = &quot;state&quot;))
plot(us_states[&quot;median_income_15&quot;])</code></pre>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-37-1.png" width="672" /></p>
<p>La fonction <code>poly2nb</code> du package <em>spdep</em> définit un réseau de voisinage à partir de polygones. Le résultat <code>vois</code> est une liste de 49 éléments où chaque élément contient les indices des polygones voisins d’un polygone donné.</p>
<pre class="r"><code>vois &lt;- poly2nb(us_states)
vois[[1]]</code></pre>
<pre><code>## [1]  5  6 36 44</code></pre>
<p>Nous pouvons illustrer ce réseau en faisant l’extraction des coordonnées du centre de chaque état, en créant une carte muette avec <code>plot(us_states["geometry"])</code>, puis en ajoutant le réseau comme couche additionnelle avec <code>plot(vois, add = TRUE, coords = coords)</code>.</p>
<pre class="r"><code>coords &lt;- st_centroid(us_states) %&gt;%
    st_coordinates()
plot(us_states[&quot;geometry&quot;])
plot(vois, add = TRUE, col = &quot;red&quot;, coords = coords)</code></pre>
<p><img src="12-Donnees_spatiales_files/figure-html/unnamed-chunk-39-1.png" width="672" /></p>
<p>Il nous reste à ajouter des poids à chaque lien du réseau avec la fonction <code>nb2listw</code>. Le style de poids “B” correspond aux poids binaires, soit 1 pour la présence de lien et 0 pour l’absence de lien entre deux états.</p>
<p>Une fois ces poids définis, nous pouvons vérifier s’il y a une autocorrélation significative du revenu médian entre états voisins, avec le test de Moran.</p>
<pre class="r"><code>poids &lt;- nb2listw(vois, style = &quot;B&quot;)

moran.test(us_states$median_income_15, poids)</code></pre>
<pre><code>## 
##  Moran I test under randomisation
## 
## data:  us_states$median_income_15  
## weights: poids    
## 
## Moran I statistic standard deviate = 4.127, p-value = 1.838e-05
## alternative hypothesis: greater
## sample estimates:
## Moran I statistic       Expectation          Variance 
##       0.342670652      -0.020833333       0.007758162</code></pre>
<p>La valeur de <span class="math inline">\(I = 0.34\)</span> est très significative à en juger par la valeur <span class="math inline">\(p\)</span> du test.</p>
<p>Finalement, nous ajustons des modèles SAR et CAR à ces données avec la fonction <code>spautolm</code> (<em>spatial autoregressive linear model</em>) de <em>spatialreg</em>. Voici le code pour un modèle SAR incluant l’effet fixe de la région (ouest, mid-ouest, sud ou nord-est).</p>
<pre class="r"><code>modsp &lt;- spautolm(median_income_15 ~ REGION, data = us_states,
                  listw = poids)
summary(modsp)</code></pre>
<pre><code>## 
## Call: spautolm(formula = median_income_15 ~ REGION, data = us_states, 
##     listw = poids)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -5632.95 -2243.24  -856.84  1781.90 11770.13 
## 
## Coefficients: 
##                Estimate Std. Error z value Pr(&gt;|z|)
## (Intercept)   28703.411   1607.825 17.8523   &lt;2e-16
## REGIONMidwest    42.832   2157.389  0.0199   0.9842
## REGIONSouth   -1131.312   1904.512 -0.5940   0.5525
## REGIONWest     -815.428   2393.545 -0.3407   0.7333
## 
## Lambda: 0.12915 LR test value: 7.7579 p-value: 0.0053479 
## Numerical Hessian standard error of lambda: 0.033239 
## 
## Log likelihood: -466.35 
## ML residual variance (sigma squared): 9804100, (sigma: 3131.2)
## Number of observations: 49 
## Number of parameters estimated: 6 
## AIC: 944.7</code></pre>
<p>La valeur donnée par <code>Lambda</code> dans le sommaire correspond au coefficient <span class="math inline">\(\rho\)</span> dans notre description du modèle. Le test du rapport de vraisemblance (<code>LR test</code>) confirme que cette corrélation spatiale résiduelle (après avoir tenu compte de l’effet de la région) est significative.</p>
<p>Pour évaluer un modèle CAR plutôt que SAR, nous devons spécifier <code>family = "CAR"</code>.</p>
<pre class="r"><code>modsp2 &lt;- spautolm(median_income_15 ~ REGION, data = us_states,
                  listw = poids, family = &quot;CAR&quot;)
summary(modsp2)</code></pre>
<pre><code>## 
## Call: spautolm(formula = median_income_15 ~ REGION, data = us_states, 
##     listw = poids, family = &quot;CAR&quot;)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -5709.20 -1999.90  -682.38  2072.01 11328.25 
## 
## Coefficients: 
##               Estimate Std. Error z value Pr(&gt;|z|)
## (Intercept)    29022.2     1484.4 19.5519   &lt;2e-16
## REGIONMidwest   -408.0     2049.4 -0.1991   0.8422
## REGIONSouth    -1436.2     1820.6 -0.7888   0.4302
## REGIONWest     -1378.0     2239.7 -0.6153   0.5384
## 
## Lambda: 0.16539 LR test value: 5.8956 p-value: 0.015179 
## Numerical Hessian standard error of lambda: 0.031414 
## 
## Log likelihood: -467.2811 
## ML residual variance (sigma squared): 10168000, (sigma: 3188.7)
## Number of observations: 49 
## Number of parameters estimated: 6 
## AIC: 946.56</code></pre>
<p>Pour un modèle CAR avec des poids binaires, la valeur de <code>Lambda</code> (que nous avions appelé <span class="math inline">\(\rho\)</span>) donne directement le coefficient de corrélation partiel entre états voisins. Notez que l’AIC ici est légèrement supérieur au modèle SAR, donc ce dernier donnait un meilleur ajustement.</p>
</div>
<div id="corrélation-spatiale-dans-des-modèles-complexes" class="section level1">
<h1>Corrélation spatiale dans des modèles complexes</h1>
<p>Comme pour le cours sur les séries temporelles, nous terminons ce cours en présentant quelques pistes pour intégrer les corrélations spatiales dans des modèles plus complexes.</p>
<div id="modèles-géostatistiques-avec-nlme" class="section level2">
<h2>Modèles géostatistiques avec <em>nlme</em></h2>
<p>Au dernier cours, nous avons vu que la fonction <code>lme</code> du package <em>nlme</em> permettait d’inclure des corrélations temporelles avec des termes de type <code>corARMA</code>. Le même package contient des fonctions de corrélation spatiale, incluant une corrélation exponentielle (<code>corExp</code>), gaussienne (<code>corGaus</code>) et sphérique (<code>corSpher</code>).</p>
<p>Voici un exemple de modèle linéaire mixte ajusté avec <code>lme</code>, où <code>v</code> est la réponse, <code>u</code> est un effet fixe et <code>groupe</code> est un effet aléatoire. L’argument <code>correlation</code> indique une corrélation exponentielle en fonction de la distance définie par les coordonnées <code>x</code> et <code>y</code>, avec un effet de pépite <code>nugget = TRUE</code>.</p>
<pre class="r"><code>library(nlme)
mod &lt;- lme(v ~ u, data, random = list(groupe = ~1),
           correlation = corExp(form = ~ x + y, nugget = TRUE))</code></pre>
<p>Notez que les limites du package <em>nlme</em> mentionnées au dernier cours s’appliquent encore ici: il n’est pas possible d’inclure plusieurs effets aléatoire croisés (non-nichés) et le package n’est pas très efficace pour l’estimation de modèles généralisés.</p>
<p>Pour intégrer une corréaltion spatiale à un modèle linéaire, sans effet aléatoire, nous pouvons remplacer <code>lme</code> par <code>gls</code>, pour <em>generalized least squares</em>. Cette fonction est semblable à <code>lm</code>, mais permet des corrélations entre les résidus du modèle.</p>
<pre class="r"><code>library(nlme)
mod &lt;- gls(v ~ u, data,
           correlation = corExp(form = ~ x + y, nugget = TRUE))</code></pre>
<p>Finalement, comme nous avons vu au dernier cours, la fonction <code>gamm</code> du package <em>mgcv</em> combine les fonctionnalités de <code>lme</code> avec la possibilité d’inclure des effets additifs (splines de lissage) pour les prédicteurs.</p>
<pre class="r"><code>library(mgcv)
mod &lt;- gamm(v ~ s(u), data, random = list(groupe = ~1), 
            correlation = corExp(form = ~ x + y, nugget = TRUE))</code></pre>
</div>
<div id="modèles-géostatistiques-avec-brms" class="section level2">
<h2>Modèles géostatistiques avec <em>brms</em></h2>
<p>Pour inclure une corrélation spatiale de type géostatistique dans un modèle bayésien estimé avec <em>brms</em>, nous devons spécifier un terme <code>gp</code>, qui décrit un processus gaussien.</p>
<pre class="r"><code>library(brms)
mod &lt;- brm(v ~ u + gp(x, y, cov = &quot;exp_quad&quot;), data)</code></pre>
<p>Le terme <code>gp</code> indique les variables contenant les coordonnées spatiales (<code>x</code>, <code>y</code>) ainsi que la forme de la covariance. Actuellement, seule la corrélation gaussienne (<code>exp_quad</code>, pour <em>exponential quadratic</em>) est disponible.*</p>
<p><span class="math inline">\(^*\)</span> Des processus gaussiens avec d’autres fonctions de corrélation sont possibles, s’ils sont codés manuellement avec Stan. Le terme “gaussien” dans “processus gaussien” réfère à la distribution normale des erreurs, pas à la forme de la corrélation spatiale.</p>
</div>
<div id="modèles-autorégressifs-spatiaux-avec-brms" class="section level2">
<h2>Modèles autorégressifs spatiaux avec <em>brms</em></h2>
<p>D’autre part, la fonction <code>brm</code> permet de spécifier une structure autorégressive spatiale avec les termes <code>sar</code> et <code>car</code>, ce qui est utile pour combiner un modèle autorégressif spatial avec des effets aléatoires non-spatiaux. Les termes <code>sar</code> et <code>car</code> sont seulement permis dans les modèles où la réponse suit une distribution normale ou <span class="math inline">\(t\)</span>, donc on ne peut pas les combiner à des modèles généralisés.</p>
<pre class="r"><code>library(brms)
mod_sar &lt;- brm(v ~ u + sar(W, type = &quot;error&quot;), data, data2 = list(W = W))
mod_car &lt;- brm(v ~ u + car(W), data, data2 = list(W = W))</code></pre>
<ul>
<li><p><code>W</code> est la matrice de poids. Puisque cette matrice ne fait pas partie des données <code>data</code>, elle est donnée séparément dans l’argument <code>data2</code>.</p></li>
<li><p>L’argument <code>type = "error"</code> dans <code>sar</code> représente le type de modèle SAR vu dans ce cours, où la portion non-expliquée de la réponse est autocorrélée. Il existe d’autres types de SAR, notamment ceux où la valeur de la réponse elle-même est autocorrélée.</p></li>
</ul>
</div>
</div>
<div id="références" class="section level1">
<h1>Références</h1>
<p>Ce cours ne constitue qu’une brève introduction aux principales techniques d’analyse spatiale utiles en sciences de l’environnement. Pour aller plus loin dans ce domaine, le manuel de Fortin et Dale donne un portrait très complet de ces méthodes et d’autres.</p>
<p>Fortin, M.-J. et Dale, M.R.T. (2005) <em>Spatial Analysis: A Guide for Ecologists</em>. Cambridge University Press: Cambridge, UK.</p>
<p>Ver Hoef, J.M., Peterson, E.E., Hooten, M.B., Hanks, E.M. et Fortin, M.-J. (2018) Spatial autoregressive models for statistical inference from ecological data. <em>Ecological Monographs</em> 88: 36-59.</p>
<p>Wiegand, T. et Moloney, K.A. (2013) <em>Handbook of Spatial Point-Pattern Analysis in Ecology</em>, CRC Press.</p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
