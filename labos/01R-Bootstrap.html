<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>La méthode du bootstrap</title>

<script src="libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="libs/bootstrap-3.3.5/css/spacelab.min.css" rel="stylesheet" />
<script src="libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="libs/navigation-1.1/tabsets.js"></script>
<link href="libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->



<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="fluid-row" id="header">



<h1 class="title toc-ignore">La méthode du bootstrap</h1>

</div>


<div id="donnees" class="section level2">
<h2>Données</h2>
<p>Pour ce laboratoire, nous utiliserons le jeu de données <a href="../donnees/sphagnum_cover.csv">sphagnum_cover.csv</a>, qui provient de l’article:</p>
<blockquote>
<p>Maanavilja, L., Kangas, L., Mehtätalo, L. and Tuittila, E.‐S. (2015), Rewetting of drained boreal spruce swamp forests results in rapid recovery of Sphagnum production. J Appl Ecol, 52: 1355-1363. <a href="https://doi.org/10.1111/1365-2664.12474">doi:10.1111/1365-2664.12474</a>)</p>
</blockquote>
<p>Ces données contiennent des mesures du pourcentage de couverture par les sphaignes (<em>sphcover</em>) pour 36 marécages boréaux divisés en trois types (<em>habitat</em>): <em>Dr</em> = drainés, <em>Re</em> = remouillés et <em>Un</em> = non-drainés.</p>
<pre class="r"><code>cover &lt;- read.csv(&quot;../donnees/sphagnum_cover.csv&quot;)
str(cover)</code></pre>
<pre><code>## &#39;data.frame&#39;:    36 obs. of  3 variables:
##  $ site    : Factor w/ 36 levels &quot;AmLuxx&quot;,&quot;Ev01VR&quot;,..: 1 5 6 9 29 31 32 33 34 10 ...
##  $ habitat : Factor w/ 3 levels &quot;Dr&quot;,&quot;Re&quot;,&quot;Un&quot;: 3 3 3 3 3 3 3 3 3 1 ...
##  $ sphcover: num  35.3 56.2 46.6 56 54.3 ...</code></pre>
</div>
<div id="estimation-de-la-couverture-moyenne-pour-les-marecages-draines" class="section level2">
<h2>1. Estimation de la couverture moyenne pour les marécages drainés</h2>
<ol style="list-style-type: lower-alpha">
<li>À partir du jeu de données, faites l’extraction des valeurs de <em>sphcover</em> pour les marécages drainés. Calculez le pourcentage de couverture moyen, ainsi que son erreur-type selon la formule classique (basée sur l’écart-type et la taille de l’échantillon). Finalement, calculez l’intervalle de confiance à 95% basé sur la distribution <span class="math inline">\(t\)</span>:</li>
</ol>
<p><span class="math display">\[(\bar{x} + t_{(n-1)0.025} s_{\bar{x}}, \bar{x} + t_{(n-1)0.975} s_{\bar{x}})\]</span></p>
<p><em>Rappel</em>: La fonction <code>qt(p, df)</code> permet d’obtenir pour une valeur <code>p</code> donnée la valeur du quantile de la distribution <span class="math inline">\(t\)</span> avec <code>df</code> degrés de liberté.</p>
<p><strong>Réponse</strong></p>
<pre class="r"><code>cov_dr &lt;- cover$sphcover[cover$habitat == &quot;Dr&quot;]

n &lt;- length(cov_dr)

# Moyenne
moy &lt;- mean(cov_dr)
moy</code></pre>
<pre><code>## [1] 7.16229</code></pre>
<pre class="r"><code># Erreur-type
err_type &lt;- sd(cov_dr) / sqrt(n)
err_type</code></pre>
<pre><code>## [1] 2.517416</code></pre>
<pre class="r"><code># Intervalle de confiance
ic &lt;- c(moy + qt(0.025, n - 1) * err_type, 
        moy + qt(0.975, n - 1) * err_type)
ic</code></pre>
<pre><code>## [1]  1.357118 12.967461</code></pre>
<ol start="2" style="list-style-type: lower-alpha">
<li>Simulez 10 000 échantillons bootstrap pour la moyenne calculée en a). Quelle est son erreur-type selon le bootstrap? Est-ce que cette statistique apparait biasée?</li>
</ol>
<p><strong>Réponse</strong></p>
<pre class="r"><code>library(boot)
set.seed(5612)

calc_moy &lt;- function(x, i) mean(x[i])

boot_moy &lt;- boot(cov_dr, calc_moy, R = 10000)

# Erreur-type
sd(boot_moy$t)</code></pre>
<pre><code>## [1] 2.386784</code></pre>
<pre class="r"><code># Biais
mean(boot_moy$t) - boot_moy$t0</code></pre>
<pre><code>## [1] 0.0328031</code></pre>
<p>Le biais est assez petit (comparé à l’erreur-type) et pourrait être dû à une erreur numérique plutôt qu’à un biais réel de la statistique.</p>
<ol start="3" style="list-style-type: lower-alpha">
<li>Comment la distribution du bootstrap diffère-t-elle d’une distribution normale? Pour répondre à cette question, il peut être utile de tracer un graphique quantile-quantile (dans le code ci-dessous, <code>res</code> est le résultat du bootstrap):</li>
</ol>
<pre class="r"><code>qqnorm(res$t)
qqline(res$t)</code></pre>
<p><strong>Réponse</strong></p>
<pre class="r"><code>qqnorm(boot_moy$t)
qqline(boot_moy$t)</code></pre>
<p><img src="01R-Bootstrap_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<p>La distribution du bootstrap est asymétrique: les plus petites valeurs s’approchent plus de la moyenne comparé à une distribution normale, tandis que les plus grandes valeurs s’en éloignent.</p>
<ol start="4" style="list-style-type: lower-alpha">
<li>Calculez l’intervalle de confiance à 95% de la moyenne selon la méthode BCa. Comment diffère-t-il de celui calculé en a) selon la formule classique? Pouvez-vous expliquer cette différence en fonction du résultat en c)?</li>
</ol>
<p><strong>Réponse</strong></p>
<pre class="r"><code># Intervalle de confiance
boot.ci(boot_moy)</code></pre>
<pre><code>## Warning in boot.ci(boot_moy): bootstrap variances needed for studentized
## intervals</code></pre>
<pre><code>## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
## Based on 10000 bootstrap replicates
## 
## CALL : 
## boot.ci(boot.out = boot_moy)
## 
## Intervals : 
## Level      Normal              Basic         
## 95%   ( 2.451, 11.807 )   ( 1.985, 11.324 )  
## 
## Level     Percentile            BCa          
## 95%   ( 3.001, 12.340 )   ( 3.430, 13.281 )  
## Calculations and Intervals on Original Scale</code></pre>
<p>L’intervalle BCa (3.44, 13.09) diffère de celui en a) (1.36, 12.97) surtout au niveau de la borne inférieure et les deux bornes sont corrigées vers le haut. En c), nous avons vu que les petites valeurs de la distribution du bootstrap sont plus rapprochées de la moyenne par rapport à la distribution normale et les plus grandes valeurs s’en éloignent.</p>
</div>
<div id="estimation-des-differences-entre-habitats" class="section level2">
<h2>2. Estimation des différences entre habitats</h2>
<ol style="list-style-type: lower-alpha">
<li>Voici la distribution des valeurs de <em>sphcover</em> dans chaque type d’habitat.</li>
</ol>
<pre class="r"><code>library(ggplot2)
ggplot(cover, aes(x = habitat, y = sphcover)) +
    geom_boxplot()</code></pre>
<p><img src="01R-Bootstrap_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<p>Quelles sont les suppositions d’un modèle d’ANOVA classique qui décrirait la couverture des sphaignes en fonction du type d’habitat? Est-ce que ces suppositions semblent respectées ici?</p>
<p><strong>Réponse</strong></p>
<p>L’ANOVA suppose que les résidus suivent une distribution normale de même variance pour chaque groupe. Ici, les distributions sont asymétriques et la variance du groupe <em>Dr</em> semble plus petite.</p>
<ol start="2" style="list-style-type: lower-alpha">
<li>Ajustez le modèle linéaire <code>sphcover ~ habitat</code> au jeu de données <code>cover</code>. Consultez le sommaire des résultats du modèle avec la fonction <code>summary</code> et les intervalles de confiance des coefficients avec la fonction <code>confint</code>. Quelle est l’interprétation de chaque coefficient? Les intervalles de confiance sont-ils plausibles?</li>
</ol>
<p><strong>Réponse</strong></p>
<pre class="r"><code>mod &lt;- lm(sphcover ~ habitat, data = cover)
summary(mod)</code></pre>
<pre><code>## 
## Call:
## lm(formula = sphcover ~ habitat, data = cover)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -33.144  -8.161  -0.596   9.659  41.371 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)    7.162      5.129   1.396   0.1719    
## habitatRe     16.141      6.282   2.569   0.0149 *  
## habitatUn     39.266      7.254   5.413 5.45e-06 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 15.39 on 33 degrees of freedom
## Multiple R-squared:  0.4742, Adjusted R-squared:  0.4424 
## F-statistic: 14.88 on 2 and 33 DF,  p-value: 2.473e-05</code></pre>
<p>L’ordonnée à l’origine <code>(Intercept)</code> est la couverture moyenne pour le groupe de référence (marécages drainés, <em>Dr</em>). Le coefficient <code>habitatRe</code> (respectivement, <code>habitatUn</code>) est la différence entre la couverture moyenne des marécages remouillés et celle des marécages drainés (respectivement, la différence entre les marécages non-drainés et drainés).</p>
<pre class="r"><code>confint(mod)</code></pre>
<pre><code>##                 2.5 %   97.5 %
## (Intercept) -3.273495 17.59807
## habitatRe    3.360128 28.92248
## habitatUn   24.507522 54.02438</code></pre>
<p>L’intervalle de confiance pour la moyenne du groupe <em>Dr</em> atteint des valeurs négatives, ce qui n’est pas possible pour un pourcentage de couverture.</p>
<ol start="3" style="list-style-type: lower-alpha">
<li>Créez une fonction avec pour arguments <code>x</code> et <code>i</code>, qui ajuste le modèle linéaire en b) en remplaçant le jeu de données original (<code>data = cover</code>) par <code>data = x[i, ]</code>, puis retourne les coefficients du modèle avec la fonction <code>coef</code>. Ensuite, appliquez <code>boot</code> au jeu de données <code>cover</code> avec la fonction créée et en effectuant 10 000 réplicats.</li>
</ol>
<p><em>Notes</em></p>
<ul>
<li><p>Lorsque le premier argument de <code>boot</code> est un jeu de données, ce sont les rangées de ce jeu de données qui sont ré-échantillonnées.</p></li>
<li><p>Puisque la statistique calculée par la fonction comporte plusieurs valeurs (chacun des coefficients), l’élément <code>t</code> du résultat de <code>boot</code> est une matrice plutôt qu’un vecteur. Les colonnes de cette matrice correspondent à chacun des coefficients dans l’ordre. Vous pouvez calculer une statistique pour chaque colonne avec la fonction <code>apply</code>, ex.: <code>apply(res$t, 2, mean)</code>. Ici, <code>2</code> indique de calculer la fonction <code>mean</code> par colonne (<code>1</code> signifierait par rangée).</p></li>
</ul>
<p><strong>Réponse</strong></p>
<pre class="r"><code>lm_hab &lt;- function(x, i)  {
    mod &lt;- lm(sphcover ~ habitat, x[i,])
    coef(mod)
}

boot_hab &lt;- boot(cover, lm_hab, R = 10000)

# Moyenne
apply(boot_hab$t, 2, mean)</code></pre>
<pre><code>## [1]  7.193903 16.132949 39.288069</code></pre>
<pre class="r"><code># Erreur-type
apply(boot_hab$t, 2, sd)</code></pre>
<pre><code>## [1] 2.529526 4.599182 6.523183</code></pre>
<p>La moyenne du bootstrap est très proche des coefficients estimés en b), mais les erreurs-types ont diminué.</p>
<p>Notons que tous les coefficients dépendent de la moyenne du groupe de référence <em>Dr</em>. La moyenne et l’écart-type de ce groupe sont fortement affectés par deux valeurs extrêmes autour de 20, comme on peut voir sur le graphique en a). Ces valeurs extrêmes seront absentes dans plusieurs échantillons bootstrap, ce qui a pour effet de réduire l’écart-type estimée pour le groupe <em>Dr</em> et ainsi réduire l’erreur-type des coefficients du modèle.</p>
<ol start="4" style="list-style-type: lower-alpha">
<li>L’application du bootstrap en c) ré-échantillonne parmi l’ensemble des rangées, ce qui fait que le nombre d’observations dans chaque type d’habitat varie d’un échantillon à l’autre. S’il est préférable de considérer ces nombres comme des quantités fixes, on peut définir les types d’habitat comme des strates en ajoutant l’argument <code>strata = cover$habitat</code> à la fonction <code>boot</code>.</li>
</ol>
<p>Répétez l’analyse en c) avec un ré-échantillonnage stratifié et comparez les erreurs-types obtenues pour chaque coefficient.</p>
<p><strong>Réponse</strong></p>
<pre class="r"><code>boot_strat &lt;- boot(cover, lm_hab, R = 10000, strata = cover$habitat)

# Moyenne
apply(boot_strat$t, 2, mean)</code></pre>
<pre><code>## [1]  7.165948 16.180594 39.323302</code></pre>
<pre class="r"><code># Erreur-type
apply(boot_strat$t, 2, sd)</code></pre>
<pre><code>## [1] 2.372362 4.490822 6.173863</code></pre>
<p>Toutes les erreurs-types ont diminué par rapport à c).</p>
<ol start="5" style="list-style-type: lower-alpha">
<li>Calculez l’intervalle de confiance pour le coefficient <code>habitatUn</code> selon le résultat du bootstrap en d). Notez qu’il faut ajouter l’argument <code>index = 3</code> à la fonction <code>boot.ci</code> pour indiquer à R de calculer l’intervalle pour le 3e coefficient.</li>
</ol>
<p><strong>Réponse</strong></p>
<pre class="r"><code>boot.ci(boot_strat, index = 3)</code></pre>
<pre><code>## Warning in boot.ci(boot_strat, index = 3): bootstrap variances needed for
## studentized intervals</code></pre>
<pre><code>## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
## Based on 10000 bootstrap replicates
## 
## CALL : 
## boot.ci(boot.out = boot_strat, index = 3)
## 
## Intervals : 
## Level      Normal              Basic         
## 95%   (27.11, 51.31 )   (27.86, 51.77 )  
## 
## Level     Percentile            BCa          
## 95%   (26.76, 50.68 )   (25.24, 49.55 )  
## Calculations and Intervals on Original Scale</code></pre>
<ol start="6" style="list-style-type: lower-alpha">
<li>Finalement, nous allons ré-échantillonner les résidus du modèle.</li>
</ol>
<ul>
<li><p>Ajustez un modèle linéaire comme en b), puis ajoutez au jeu de données <code>cover</code>une colonne pour les valeurs attendues (<code>fitted</code>) du modèle.</p></li>
<li><p>Écrivez une fonction qui crée un nouveau jeu de données en additionnant un vecteur ré-échantillonné <code>x[i]</code> aux valeurs attendues pour produire une nouvelle variable réponse, puis qui ajuste un modèle avec cette nouvelle variable réponse en fonction de l’habitat.</p></li>
<li><p>Simulez 10 000 échantillons avec la fonction <code>boot</code>, avec comme arguments (1) le vecteurs de résidus (<code>residuals</code>) du modèle et (2) la fonction créée ci-dessus. Ne spécifiez pas de strates. Calculez de nouveau la moyenne, l’erreur-type et l’intervalle de confiance à 95% des coefficients.</p></li>
</ul>
<p>Le ré-échantillonnage des résidus est-il un bon choix pour ces données?</p>
<p><strong>Réponse</strong></p>
<pre class="r"><code>mod &lt;- lm(sphcover ~ habitat, data = cover)
cover$fitted &lt;- fitted(mod)

lm_resid &lt;- function(x, i) {
    cover$cover_new &lt;- cover$fitted + x[i]
    mod_new &lt;- lm(cover_new ~ habitat, data = cover)
    coef(mod_new)
}

boot_resid &lt;- boot(residuals(mod), lm_resid, R = 10000)

# Moyenne
apply(boot_resid$t, 2, mean)</code></pre>
<pre><code>## [1]  7.155993 16.157210 39.340901</code></pre>
<pre class="r"><code># Erreur-type
apply(boot_resid$t, 2, sd)</code></pre>
<pre><code>## [1] 4.941989 6.059448 6.965119</code></pre>
<pre class="r"><code>boot.ci(boot_resid, index = 3)</code></pre>
<pre><code>## Warning in boot.ci(boot_resid, index = 3): bootstrap variances needed for
## studentized intervals</code></pre>
<pre><code>## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
## Based on 10000 bootstrap replicates
## 
## CALL : 
## boot.ci(boot.out = boot_resid, index = 3)
## 
## Intervals : 
## Level      Normal              Basic         
## 95%   (25.54, 52.84 )   (25.71, 52.94 )  
## 
## Level     Percentile            BCa          
## 95%   (25.59, 52.82 )   (25.23, 52.53 )  
## Calculations and Intervals on Original Scale</code></pre>
<p>Le ré-échantillonnage des résidus suppose que les résidus dans chaque groupe proviennent de la même distribution. Dans ce cas-ci, les variances ne sont pas homogènes entre les groupes, donc il est préférable de ré-échantilonner les observations.</p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
